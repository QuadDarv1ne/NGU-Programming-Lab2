package main

import (
	"fmt"
	"math"
)

/**
 * minFlipsToChessboard вычисляет минимальное количество переворотов пар монет
 * для преобразования доски в шахматный узор
 *
 * @param board - двумерный срез, представляющий доску (0 - решка, 1 - орел)
 * @return минимальное количество переворотов или -1, если решение невозможно
 *
 * Алгоритм:
 * 1. Пробуем оба возможных шахматных узора:
 *    a. Начинающийся с 0 в левом верхнем углу
 *    b. Начинающийся с 1 в левом верхнем углу
 * 2. Для каждого узора:
 *    a. Создаем временную копию доски
 *    b. Проверяем все ячейки:
 *       - Если значение не соответствует узору, ищем соседа для совместного переворота
 *    c. Если все несоответствия исправлены, сохраняем количество переворотов
 * 3. Возвращаем минимальное количество переворотов из двух вариантов
 */
func minFlipsToChessboard(board [][]int) int {
	rows := len(board)
	cols := len(board[0])
	minFlips := math.MaxInt32

	// Направления для поиска соседей (вверх, вниз, влево, вправо)
	dx := []int{-1, 1, 0, 0}
	dy := []int{0, 0, -1, 1}

	// Пробуем оба возможных шахматных узора
	for pattern := 0; pattern < 2; pattern++ {
		// Создаем копию доски
		temp := make([][]int, rows)
		for i := range temp {
			temp[i] = make([]int, cols)
			copy(temp[i], board[i])
		}

		flips := 0       // Счетчик переворотов
		possible := true // Флаг возможности решения

		// Проверяем все ячейки доски
		for i := 0; i < rows && possible; i++ {
			for j := 0; j < cols && possible; j++ {
				// Ожидаемое значение для текущей позиции
				expected := (i + j + pattern) % 2

				// Если текущее значение не соответствует ожидаемому
				if temp[i][j] != expected {
					flipped := false // Флаг успешного переворота

					// Проверяем всех соседей
					for d := 0; d < 4; d++ {
						ni := i + dx[d] // Координата соседа по строке
						nj := j + dy[d] // Координата соседа по столбцу

						// Проверяем, что сосед в пределах доски
						if ni >= 0 && ni < rows && nj >= 0 && nj < cols {
							// Если сосед тоже не соответствует и их переворот исправит ситуацию
							if temp[ni][nj] != expected &&
								(ni+nj+pattern)%2 != temp[ni][nj] {
								// Переворачиваем обе монеты
								temp[i][j] ^= 1
								temp[ni][nj] ^= 1
								flips++
								flipped = true
								break
							}
						}
					}
					// Если не нашли подходящего соседа - решение невозможно
					if !flipped {
						possible = false
					}
				}
			}
		}

		// Если решение возможно и количество переворотов минимально
		if possible && flips < minFlips {
			minFlips = flips
		}
	}

	// Возвращаем результат или -1, если решение невозможно
	if minFlips == math.MaxInt32 {
		return -1
	}
	return minFlips
}

func main() {
	/*
	 * Основная функция демонстрации работы алгоритма
	 *
	 * Выполняет:
	 * 1. Ввод размеров доски
	 * 2. Ввод конфигурации монет
	 * 3. Вычисление минимального количества переворотов
	 * 4. Вывод результата
	 */
	var rows, cols int
	fmt.Print("Введите размеры доски (строки столбцы): ")
	fmt.Scan(&rows, &cols)

	fmt.Println("Введите конфигурацию доски (0 - решка, 1 - орел):")
	board := make([][]int, rows)
	for i := range board {
		board[i] = make([]int, cols)
		for j := range board[i] {
			fmt.Scan(&board[i][j])
		}
	}

	result := minFlipsToChessboard(board)
	if result == -1 {
		fmt.Println("Невозможно получить шахматный узор")
	} else {
		fmt.Printf("Минимальное количество переворотов: %d\n", result)
	}
}
