# Лабораторная работа №6: Алгоритмы обработки двумерных массивов

**Реализация трех задач обработки матриц и клеточного автомата на языках C++ и Go:**

1. Обработка матрицы: реверс строк, поиск экстремумов
2. Генерация матрицы по шаблону
3. Реализация клеточного автомата Конвея с классическими и пользовательскими правилами

## Задача №1: Обработка матрицы

## Описание

- Генерация квадратной матрицы N×N случайными вещественными числами в диапазоне [-50, 50]
- Реверс строк матрицы без использования дополнительного массива
- Поиск второго минимального и максимального элементов в матрице

## Алгоритм

1. Инициализация матрицы случайными числами
2. Реверс строк с помощью `std::reverse (C++)` или `swap (Go)`
3. Однопроходный поиск экстремумов с обновлением значений
4. Форматированный вывод результатов

## Особенности реализации

- Эффективный поиск экстремумов за `O(N²)`
- Корректная обработка матриц любого размера
- Точный вывод чисел с контролем точности

## Запуск

### C++

```bash
g++ -o task1 task1.cpp && ./task1
```

### Go

```bash
go run task1.go
```

## Задача №2: Генерация матрицы по шаблону

## Описание

- **Создание квадратной матрицы по формуле:** `a[i][j] = 100 + 5*(i + j)`
- Размер матрицы вводится пользователем
- Форматированный вывод матрицы

## Алгоритм

1. Ввод размера матрицы N
2. Последовательное вычисление элементов по формуле
3. Вывод матрицы с выравниванием столбцов

## Особенности

- Минимальная вычислительная сложность `O(N²)`
- Четкое форматирование вывода
- Простота и эффективность реализации

## Запуск

### C++
```bash
g++ -o task2 task2.cpp && ./task2
```

### Go

```bash
go run task2.go
```

# Задача №3: Клеточный автомат Конвея

## Описание

- Реализация классического клеточного автомата "Жизнь"
- **Поддержка двух наборов правил:**
  • **Классические:** выживание при 2-3 соседях, рождение при 3
  • **Пользовательские:** выживание при 2 или 4 соседях, рождение при 4
- Визуализация в консоли с псевдографикой
- **Поддержка устойчивых фигур:** `Block`, `Beehive`, `Loaf`, `Boat`
- Генерация случайных начальных состояний

## Алгоритм

1. Инициализация сетки (устойчивая фигура или случайное состояние)
2. Расчет следующего поколения с учетом правил
3. Тороидальная обработка границ
4. Визуализация состояния
5. Циклическое обновление с задержкой 250 мс

## Особенности

- Кросс-платформенная реализация
- Тороидальные границы (бесшовный мир)
- Плавная анимация с контролем скорости
- Четкое разделение логики и визуализации

## Демонстрация

1. Устойчивые фигуры с классическими правилами (5 поколений)
2. Случайные конфигурации с пользовательскими правилами (100 поколений)

## Запуск

### C++

```bash
g++ -o task3 task3.cpp && ./task3
```

### Go

```bash
go run task3.go
```

# Тестирование

- **Задачи 1-2:** проверены на матрицах размером 3, 5, 10
- **Задача 3:** проверены все устойчивые фигуры, 10+ случайных конфигураций
- Подтверждена корректность работы на `Windows`/`Linux`/`macOS`

# Наблюдения

- Пользовательские правила приводят к более хаотичному поведению
- Формируются стабильные структуры с "дырами" при custom-правилах
- Случайные конфигурации быстрее стабилизируются
- Появляются волнообразные паттерны при длительной симуляции

# Структура проекта

```textline
lab_work/
├── task1/
│   ├── task1.cpp
│   └── task1.go
├── task2/
│   ├── task2.cpp
│   └── task2.go
├── task3/
│   ├── task3.cpp
│   └── task3.go
└── README.md
```

---

**Преподаватель:** Дуплей Максим Игоревич

**TG:** @quadd4rv1n7

**Дата:** 30.05.2025
