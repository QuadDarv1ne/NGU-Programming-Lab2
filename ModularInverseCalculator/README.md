# Modular Inverse Calculator

Эта программа вычисляет модульный обратный элемент (d) для уравнения c * d ≡ 1 mod m
с использованием расширенного алгоритма Евклида.

**Также реализованы вспомогательные функции:**

- Проверка чисел на простоту
- Быстрое возведение в степень по модулю
- Подтверждение корректности результата

## Особенности реализации

1. **Итеративный алгоритм Евклида** - вместо рекурсии для предотвращения переполнения стека
2. **Автоматическая нормализация**:
   - Обработка отрицательных входных значений
   - Коррекция результата в диапазон [0, m-1]
3. **Двойная проверка результатов**:
   - Основной метод: расширенный алгоритм Евклида
   - Дополнительная проверка через теорему Ферма (для простых модулей)
4. **Оптимизированные алгоритмы**:
   - Быстрое возведение в степень (O(log n))
   - Эффективная проверка простоты (пропуск чётных делителей)

## Требования

- C++17 (используется structured binding)
- Поддержка стандартной библиотеки: <tuple>, <cmath>

## Использование

1. Скомпилируйте программу:
   `g++ -std=c++17 -o inverse_calculator ModularInverseCalculator.cpp`
2. Запустите программу:
   `./inverse_calculator`
3. Введите значения при запросе:
   - Целое число `a` (элемент, для которого ищем обратный)
   - Модуль `m` (положительное целое число)

## Пример вывода

```printline
Введите число a и модуль m: 7 15

Обратный элемент (алгоритм Евклида): 13
Проверка: 7 * 13 mod 15 = 1

Дополнительная проверка (теорема Ферма): 
Обратный элемент: 13
Проверка: 7 * 13 mod 15 = 1
```

## Обработка ошибок

**Программа обнаруживает следующие ошибки:**

1. Модуль не положительный
2. Обратный элемент не существует (gcd(a, m) ≠ 1)
3. Некорректный ввод (нечисловые значения)

## Математические основы

```printline
Основное уравнение: a * d ≡ 1 mod m
Решение существует только когда gcd(a, m) = 1
Для простых модулей: d ≡ a^{m-2} mod m (по теореме Ферма)
```

---

**Преподаватель:** Дуплей Максим Игоревич

**Дата:** 04.06.2025
